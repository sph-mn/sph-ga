// Generated by CoffeeScript 2.7.0
var sph_ga,
  indexOf = [].indexOf;

sph_ga = (function() {
  var determinant_generic;

  class sph_ga {
    constructor(metric, options = {}) {
      var point, ref, ref1;
      this.n = metric.length;
      this.is_conformal = !!options.conformal;
      if (!Array.isArray(metric[0])) {
        if (this.is_conformal) {
          this.n += 2;
          metric.push(0, 0);
        }
        metric = this.flat_metric_to_full(metric, this.n);
        if (this.is_conformal) {
          metric[this.n - 1][this.n - 2] = -1;
          metric[this.n - 2][this.n - 1] = -1;
        }
      }
      [this.is_symmetric, this.is_diagonal, this.null_vectors] = this.metric_properties(metric, this.n);
      if (!this.is_symmetric) {
        throw new Error("the metric must be symmetric in the non-null part");
      }
      if (this.is_conformal) {
        if (2 !== this.null_vectors) {
          throw new Error("only two null vectors are allowed with \"conformal: true\". use a custom metric instead");
        }
        if (!this.is_diagonal) {
          throw new Error("only diagonal metrics are allowed with \"conformal: true\". use a custom metric instead");
        }
      }
      if (this.null_vectors) {
        this.null_vector_start = this.n - this.null_vectors;
        this.id_null = this.id_from_indices((function() {
          var results = [];
          for (var l = ref = this.null_vector_start + 1, ref1 = this.n; ref <= ref1 ? l <= ref1 : l >= ref1; ref <= ref1 ? l++ : l--){ results.push(l); }
          return results;
        }).apply(this));
      }
      this.metric = metric;
      this.pseudoscalar_id = (1 << this.n) - 1;
      if (this.is_diagonal) {
        this.ip_metric = function(indices) {
          var i;
          return this.array_product((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = indices.length; l < len; l++) {
              i = indices[l];
              results.push(this.metric[i][i]);
            }
            return results;
          }).call(this));
        };
      } else {
        this.ip_metric = function(indices) {
          var i, j;
          if (!indices.length) {
            return 1;
          }
          return this.determinant((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = indices.length; l < len; l++) {
              i = indices[l];
              results.push((function() {
                var len1, o, results1;
                results1 = [];
                for (o = 0, len1 = indices.length; o < len1; o++) {
                  j = indices[o];
                  results1.push(this.metric[i][j]);
                }
                return results1;
              }).call(this));
            }
            return results;
          }).call(this));
        };
      }
      if (this.is_conformal) {
        this.eo_bit_index = this.n - 2;
        this.ei_bit_index = this.n - 1;
        this.eo_id = 1 << this.eo_bit_index;
        this.ei_id = 1 << this.ei_bit_index;
        this.eo_index = this.eo_bit_index + 1;
        this.ei_index = this.ei_bit_index + 1;
        this.eo = function(coeff) {
          return [[this.eo_id, coeff, 1]];
        };
        this.ei = function(coeff) {
          return [[this.ei_id, coeff, 1]];
        };
        point = function(euclidean_coeffs) {
          var ei_coeff;
          ei_coeff = 0.5 * this.array_sum(this.array_product(euclidean_coeffs));
          return this.vector([0].concat(euclidean_coeffs).concat([1, ei_coeff]));
        };
      }
    }

    coeffs_add(coeffs, id, coeff, grade) {
      if (coeffs[id] != null) {
        return coeffs[id][0] += coeff;
      } else {
        return coeffs[id] = [coeff, grade];
      }
    }

    array_product(a) {
      return a.reduce((function(b, a) {
        return a * b;
      }), 1);
    }

    array_sum(a) {
      return a.reduce((function(b, a) {
        return a + b;
      }), 0);
    }

    array_diff(a, b) {
      return a.filter(function(c) {
        return !(indexOf.call(b, c) >= 0);
      });
    }

    basis_blade(i, coeff) {
      if (i) {
        return [1 << (i - 1), coeff, 1];
      } else {
        return [0, coeff, 0];
      }
    }

    basis(i, coeff) {
      return [this.basis_blade(i, (coeff != null ? coeff : 1))];
    }

    vector(coeffs) {
      var a, i, l, len, results;
      results = [];
      for (i = l = 0, len = coeffs.length; l < len; i = ++l) {
        a = coeffs[i];
        if (a) {
          results.push(this.basis_blade(i, a));
        }
      }
      return results;
    }

    s(coeff) {
      return [[0, coeff, 0]];
    }

    id_from_indices(indices) {
      return indices.reduce((function(id, i) {
        return id |= 1 << (i - 1);
      }), 0);
    }

    id_from_bit_indices(indices) {
      return indices.reduce((function(id, i) {
        return id |= 1 << i;
      }), 0);
    }

    mv(terms) {
      var coeff, indices, l, len, results;
      results = [];
      for (l = 0, len = terms.length; l < len; l++) {
        [indices, coeff] = terms[l];
        results.push(this.blade(indices, coeff));
      }
      return results;
    }

    map_grade_factor(a, f) {
      var coeff, grade, id, l, len, results;
      results = [];
      for (l = 0, len = a.length; l < len; l++) {
        [id, coeff, grade] = a[l];
        results.push([id, coeff * f(grade), grade]);
      }
      return results;
    }

    involute(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** grade;
      });
    }

    scale(mv, a) {
      var coeff, grade, id, l, len, results;
      results = [];
      for (l = 0, len = mv.length; l < len; l++) {
        [id, coeff, grade] = mv[l];
        results.push([id, coeff * a, grade]);
      }
      return results;
    }

    negate(a) {
      return this.scale(a, -1);
    }

    conjugate(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade + 1)) >> 1);
      });
    }

    reverse(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade - 1)) >> 1);
      });
    }

    add(a, b) {
      return this.combine(a, b, 1);
    }

    subtract(a, b) {
      return this.combine(a, b, -1);
    }

    sp(a, b) {
      return this.gp(this.gp(a, b), this.inverse(a));
    }

    pseudoscalar() {
      var ref;
      return [
        this.blade((function() {
          var results = [];
          for (var l = 1, ref = this.n; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--){ results.push(l); }
          return results;
        }).apply(this),
        1)
      ];
    }

    grade(a) {
      return a[a.length - 1][2];
    }

    blade_id(a) {
      return a[0];
    }

    blade_coeff(a) {
      return a[1];
    }

    blade_grade(a) {
      return a[2];
    }

    get(a, id) {
      var b, l, len;
      for (l = 0, len = a.length; l < len; l++) {
        b = a[l];
        if (id === b[0]) {
          return b;
        }
      }
    }

    blade(indices, coeff) {
      if (indices[0]) {
        return [this.id_from_indices(indices), coeff, indices.length];
      } else {
        return [this.id_from_indices(indices.slice(1)), coeff, indices.length - 1];
      }
    }

    coeffs_to_mv(coeffs) {
      var a, coeff, grade, id;
      a = (function() {
        var results;
        results = [];
        for (id in coeffs) {
          [coeff, grade] = coeffs[id];
          if (coeff !== 0) {
            results.push([parseInt(id), coeff, grade]);
          }
        }
        return results;
      })();
      if (a.length) {
        return a;
      } else {
        return [[0, 0, 0]];
      }
    }

    id_indices(id) {
      var a, l, len, ref, results;
      if (id) {
        ref = this.id_bit_indices(id);
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          a = ref[l];
          results.push(1 + a);
        }
        return results;
      } else {
        return [0];
      }
    }

    id_bit_indices(id) {
      var a, i;
      if (id in this.id_bit_indices_cache) {
        return this.id_bit_indices_cache[id];
      }
      a = (function() {
        var l, ref, results;
        results = [];
        for (i = l = 0, ref = this.n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          if (id & (1 << i)) {
            results.push(i);
          }
        }
        return results;
      }).call(this);
      this.id_bit_indices_cache[id] = a;
      return a;
    }

    flat_metric_to_full(metric, n) {
      var a, b, i, l, ref;
      a = Array(n);
      for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        b = Array(n).fill(0);
        b[i] = metric[i];
        a[i] = b;
      }
      return a;
    }

    metric_properties(metric, n) {
      var di, first_zero, i, is_diagonal, j, k, l, null_vectors, o, p, ref, ref1, ref2, ref3, ref4, ref5;
      null_vectors = 0;
      first_zero = n;
      is_diagonal = true;
      for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        di = metric[i][i];
        if (di === 0) {
          null_vectors += 1;
          if (first_zero === n) {
            first_zero = i;
          }
        } else {
          if (first_zero < n || ((ref1 = !di) === 1 || ref1 === (-1))) {
            is_diagonal = false;
            break;
          }
        }
        for (j = o = ref2 = i + 1, ref3 = n; (ref2 <= ref3 ? o < ref3 : o > ref3); j = ref2 <= ref3 ? ++o : --o) {
          if (i < first_zero) {
            if (metric[i][j] !== metric[j][i]) {
              return [false, false, null_vectors];
            }
            if (metric[i][j] !== 0) {
              is_diagonal = false;
              break;
            }
          }
        }
        if (!is_diagonal) {
          break;
        }
      }
      for (k = p = ref4 = first_zero, ref5 = n; (ref4 <= ref5 ? p < ref5 : p > ref5); k = ref4 <= ref5 ? ++p : --p) {
        if (metric[k][k] !== 0) {
          return [false, false, null_vectors];
        }
      }
      return [true, is_diagonal, null_vectors];
    }

    id_grade(a) {
      var b, n;
      if (a in this.id_grade_cache) {
        return this.id_grade_cache[a];
      }
      n = 0;
      b = a;
      while (b !== 0) {
        b &= b - 1;
        n += 1;
      }
      this.id_grade_cache[a] = n;
      return n;
    }

    determinant(matrix) {
      var n;
      n = matrix.length;
      if (1 === n) {
        return matrix[0][0];
      } else if (2 === n) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      } else if (3 === n) {
        return matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
      } else if (4 === n) {
        return matrix[0][0] * (matrix[1][1] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) + matrix[1][3] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1])) - matrix[0][1] * (matrix[1][0] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0])) + matrix[0][2] * (matrix[1][0] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0])) - matrix[0][3] * (matrix[1][0] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0]) + matrix[1][2] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0]));
      } else {
        return this.determinant_generic(matrix, n);
      }
    }

    for_each_combination(array, n, f) {
      var generate;
      generate = function(prefix, rest, k) {
        var first;
        if (k === 0) {
          f(prefix);
          return;
        }
        if (rest.length === 0) {
          return;
        }
        [first, ...rest] = rest;
        generate(prefix.concat([first]), rest, k - 1);
        return generate(prefix, rest, k);
      };
      return generate([], array, n);
    }

    sign(a, b) { // count sorted inversions
      var c, i, j;
      c = 0;
      i = 0;
      j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] <= b[j]) {
          i += 1;
        } else {
          c += a.length - i;
          j += 1;
        }
      }
      return (-1) ** c;
    }

    ip(a, b) {
      var coeff, coeff_a, coeff_b, coeffs, grade, grade_a, grade_b, id, id_a, id_a_e, id_a_n, id_b, id_b_e, id_b_n, id_c, indices_a, indices_b, indices_c, l, len, len1, m, o, sign;
      coeffs = {};
      if (1 === a.length && !a[0][0]) {
        if (1 === b.length && !b[0][0]) {
          return this.null_scalar;
        } else {
          return (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = b.length; l < len; l++) {
              [id, coeff, grade] = b[l];
              results.push([id, coeff * a[0][1], grade]);
            }
            return results;
          })();
        }
      } else if (1 === b.length && !b[0][0]) {
        return this.null_scalar;
      }
      for (l = 0, len = a.length; l < len; l++) {
        [id_a, coeff_a, grade_a] = a[l];
        indices_a = this.id_bit_indices(id_a);
        id_a_e = id_a & ~this.id_null;
        id_a_n = id_a & this.id_null;
        for (o = 0, len1 = b.length; o < len1; o++) {
          [id_b, coeff_b, grade_b] = b[o];
          if (id_a === id_b) {
            if (m = this.ip_metric(indices_a)) {
              this.coeffs_add(coeffs, 0, coeff_a * coeff_b * m, 0);
            }
            continue;
          }
          id_b_e = id_b & ~this.id_null;
          id_b_n = id_b & this.id_null;
          indices_b = this.id_bit_indices(id_b);
          if (id_a_n || id_b_n) {
            sign = this.sign(indices_a, indices_b);
            this.for_each_combination(indices_b, indices_a.length, (indices_c) => {
              var i, id_c, p, ref;
              m = 1;
              for (i = p = 0, ref = indices_a.length; (0 <= ref ? p < ref : p > ref); i = 0 <= ref ? ++p : --p) {
                m *= this.metric[indices_a[i]][indices_c[i]];
              }
              if (!m) {
                return;
              }
              id_c = this.id_from_bit_indices(this.array_diff(indices_b, indices_c));
              return this.coeffs_add(coeffs, id_c, coeff_a * coeff_b * sign * m, this.id_grade(id_c));
            });
          } else if ((id_a_e || id_b_e) && grade_a <= grade_b && id_a_e === (id_b_e & id_a_e)) {
            id_c = id_a_e ^ id_b_e;
            indices_c = this.id_bit_indices(id_c);
            if (m = this.ip_metric(indices_c)) {
              sign = this.sign(indices_a, indices_c);
              this.coeffs_add(coeffs, id_c, coeff_a * coeff_b * sign * m, grade_b - grade_a);
            }
          }
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    ep(a, b) {
      var coeff_a, coeff_b, coeffs, grade_a, grade_b, id_a, id_b, indices_a, l, len, len1, len_a, o, sign;
      coeffs = {};
      for (l = 0, len = a.length; l < len; l++) {
        [id_a, coeff_a, grade_a] = a[l];
        indices_a = this.id_bit_indices(id_a);
        len_a = indices_a.length;
        for (o = 0, len1 = b.length; o < len1; o++) {
          [id_b, coeff_b, grade_b] = b[o];
          if (!(id_a & id_b)) {
            if (!grade_a) {
              if (grade_b) {
                this.coeffs_add(coeffs, id_b, coeff_a * coeff_b, grade_b);
              }
            } else if (!grade_b) {
              this.coeffs_add(coeffs, id_a, coeff_a * coeff_b, grade_a);
            } else {
              sign = this.sign(indices_a, this.id_bit_indices(id_b));
              this.coeffs_add(coeffs, id_a | id_b, sign * coeff_a * coeff_b, grade_a + grade_b);
            }
          }
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    gp(a, b) {
      return this.s(0);
    }

    combine(a, b, scalar = 1) {
      var coeff, coeffs, grade, id, l, len, len1, o, results;
      coeffs = {};
      for (l = 0, len = a.length; l < len; l++) {
        [id, coeff, grade] = a[l];
        coeffs[id] = [coeff, grade];
      }
      for (o = 0, len1 = b.length; o < len1; o++) {
        [id, coeff, grade] = b[o];
        if (coeffs[id] != null) {
          coeffs[id][0] += coeff * scalar;
        } else {
          coeffs[id] = [coeff * scalar, grade];
        }
      }
      results = [];
      for (id in coeffs) {
        [coeff, grade] = coeffs[id];
        if (coeff !== 0) {
          results.push([parseInt(id), coeff, grade]);
        }
      }
      return results;
    }

    inverse(a) {
      var a_reverse, coeff, denom, denom_mv, grade, id, l, len, len1, o, results;
      a_reverse = this.reverse(a);
      denom_mv = this.gp(a, a_reverse);
      denom = 0;
      for (l = 0, len = denom_mv.length; l < len; l++) {
        [id, coeff, grade] = denom_mv[l];
        if (id === 0) {
          denom = coeff;
          break;
        }
      }
      if (denom === 0) {
        throw new Error("multivector is not invertible (denominator is zero).");
      }
      results = [];
      for (o = 0, len1 = a_reverse.length; o < len1; o++) {
        [id, coeff, grade] = a_reverse[o];
        results.push([parseInt(id), coeff / denom, grade]);
      }
      return results;
    }

    blade_to_string(a) {
      var base, coeff, grade, id;
      [id, coeff, grade] = a;
      if (id) {
        base = "e" + this.id_bit_indices(id).map(function(b) {
          return b + 1;
        }).join("_");
        if (1 === coeff) {
          return base;
        } else {
          return coeff + base;
        }
      } else {
        return coeff;
      }
    }

    mv_to_string(a) {
      var b;
      return ((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = a.length; l < len; l++) {
          b = a[l];
          results.push(this.blade_to_string(b));
        }
        return results;
      }).call(this)).join(" + ");
    }

    blade_from_string(a) {
      var coeff, id, indices, left_number, letters, match, n, result, right_numbers;
      match = a.match(/^(?:(\d+(?:\.\d+)?))?([a-z]+)?(?:([\d_]+))?$/);
      if (!match) {
        return null;
      }
      left_number = match[1] != null ? parseFloat(match[1]) : null;
      letters = match[2] != null ? match[2] : null;
      right_numbers = match[3] != null ? (function() {
        var l, len, ref, results;
        ref = match[3].split("_");
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          n = ref[l];
          results.push(parseInt(n));
        }
        return results;
      })() : null;
      result = [];
      coeff = left_number != null ? left_number : 1;
      indices = right_numbers != null ? right_numbers : [];
      if (letters != null) {
        switch (letters) {
          case "eo":
            id = c3.eo_id;
            break;
          case "ei":
            id = c3.ei_id;
            break;
          default:
            id = this.id_from_indices(right_numbers);
        }
      } else {
        id = 0;
      }
      return [id, coeff, this.id_grade(id)];
    }

    mv_from_string(a) {
      var b, l, len, ref, results;
      ref = a.split(" + ");
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        b = ref[l];
        results.push(this.blade_from_string(b));
      }
      return results;
    }

  };

  sph_ga.prototype.id_grade_cache = {};

  sph_ga.prototype.id_bit_indices_cache = {};

  sph_ga.prototype.null_scalar = [[0, 0, 0]];

  determinant_generic = function(a, n) {
    var b, c, i, j, l, o, ref, ref1, sign;
    if (n === 1) {
      return a[0][0];
    }
    b = 0;
    for (j = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); j = 0 <= ref ? ++l : --l) {
      for (i = o = 1, ref1 = n; (1 <= ref1 ? o < ref1 : o > ref1); i = 1 <= ref1 ? ++o : --o) {
        c = a[i].slice(0, j).concat(a[i].slice(j + 1));
      }
      sign = 0 === j % 2 ? 1 : -1;
      b += sign * a[0][j] * determinant_generic(c);
    }
    return b;
  };

  return sph_ga;

}).call(this);

if (typeof module !== "undefined" && module.exports) {
  module.exports = sph_ga;
} else {
  window.sph_ga = sph_ga;
}
