// Generated by CoffeeScript 2.7.0
var sph_ga;

sph_ga = class sph_ga {
  constructor(metric) {
    this.n = metric.length;
    this.metric = metric;
    this.blade_count = 2 ** this.n;
  }

  blade(index) {
    if (index) {
      return [[1 << (index - 1), 1, 1]];
    } else {
      return [[0, 1, 0]];
    }
  }

  apply_grade_sign(a, sign_function) {
    var coeff, grade, id, j, len, results;
    results = [];
    for (j = 0, len = a.length; j < len; j++) {
      [id, coeff, grade] = a[j];
      results.push([id, coeff * sign_function(grade), grade]);
    }
    return results;
  }

  involute(a) {
    return this.apply_grade_sign(a, function(grade) {
      return (-1) ** grade;
    });
  }

  conjugate(a) {
    return this.apply_grade_sign(a, function(grade) {
      return (-1) ** ((grade * (grade + 1)) >> 1);
    });
  }

  reverse(a) {
    return this.apply_grade_sign(a, function(grade) {
      return (-1) ** ((grade * (grade - 1)) >> 1);
    });
  }

  add(a, b) {
    return this.combine(a, b, 1);
  }

  subtract(a, b) {
    return this.combine(a, b, -1);
  }

  sp(a, b) {
    return this.gp(this.gp(a, b), this.inverse(a));
  }

  pseudoscalar() {
    var ref;
    return (function() {
      var results = [];
      for (var j = 1, ref = this.n; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).reduce((function(ps, a) {
      return this.ep(ps, this.blade(a));
    }), this.blade(0));
  }

  grade(a) {
    var n;
    n = 0;
    while (a !== 0) {
      a &= a - 1;
      n += 1;
    }
    return n;
  }

  antisymmetric_sign(a, b) {
    var count, count_b, j, k, ref;
    count = 0;
    count_b = 0;
    for (k = j = 0, ref = this.n - 1; (0 <= ref ? j < ref : j > ref); k = 0 <= ref ? ++j : --j) {
      if ((a >> k) & 1) {
        count += count_b;
      }
      if ((b >> k) & 1) {
        count_b += 1;
      }
    }
    if ((count & 1) === 0) {
      return 1;
    } else {
      return -1;
    }
  }

  metric_sign(a, b) {
    var c, i, sign;
    c = a & b;
    sign = 1;
    i = 0;
    while (c !== 0) {
      if (c & 1) {
        sign *= this.metric[i];
      }
      c >>= 1;
      i += 1;
    }
    return sign;
  }

  gp(a, b) {
    var coeff, coeff_a, coeff_b, coeffs, grade, grade_a, grade_b, id, id_a, id_b, j, l, len, len1, results, sign;
    coeffs = {};
    for (j = 0, len = a.length; j < len; j++) {
      [id_a, coeff_a, grade_a] = a[j];
      for (l = 0, len1 = b.length; l < len1; l++) {
        [id_b, coeff_b, grade_b] = b[l];
        id = id_a ^ id_b;
        sign = this.antisymmetric_sign(id_a, id_b) * this.metric_sign(id_a, id_b);
        coeff = sign * coeff_a * coeff_b;
        if (coeffs[id] != null) {
          coeffs[id][0] += coeff;
        } else {
          coeffs[id] = [coeff, this.grade(id)];
        }
      }
    }
    results = [];
    for (id in coeffs) {
      [coeff, grade] = coeffs[id];
      if (coeff !== 0) {
        results.push([id, coeff, grade]);
      }
    }
    return results;
  }

  combine(a, b, scalar = 1) {
    var coeff, coeffs, grade, id, j, l, len, len1, results;
    coeffs = {};
    for (j = 0, len = a.length; j < len; j++) {
      [id, coeff, grade] = a[j];
      coeffs[id] = [coeff, grade];
    }
    for (l = 0, len1 = b.length; l < len1; l++) {
      [id, coeff, grade] = b[l];
      if (coeffs[id] != null) {
        coeffs[id][0] += coeff * scalar;
      } else {
        coeffs[id] = [coeff * scalar, grade];
      }
    }
    results = [];
    for (id in coeffs) {
      [coeff, grade] = coeffs[id];
      if (coeff !== 0) {
        results.push([id, coeff, grade]);
      }
    }
    return results;
  }

  ip(a, b) {
    var coeff, coeff_a, coeff_b, coeffs, grade, grade_a, grade_b, id, id_a, id_b, j, l, len, len1, results, sign;
    coeffs = {};
    for (j = 0, len = a.length; j < len; j++) {
      [id_a, coeff_a, grade_a] = a[j];
      for (l = 0, len1 = b.length; l < len1; l++) {
        [id_b, coeff_b, grade_b] = b[l];
        if (grade_a <= grade_b) {
          id = id_a ^ id_b;
          grade = grade_b - grade_a;
          if (this.grade(id) === grade) {
            sign = this.antisymmetric_sign(id_a, id_b) * this.metric_sign(id_a, id_b);
            coeff = sign * coeff_a * coeff_b;
            if (coeffs[id] != null) {
              coeffs[id][0] += coeff;
            } else {
              coeffs[id] = [coeff, grade];
            }
          }
        }
      }
    }
    results = [];
    for (id in coeffs) {
      [coeff, grade] = coeffs[id];
      if (coeff !== 0) {
        results.push([id, coeff, grade]);
      }
    }
    return results;
  }

  ep(a, b) {
    var coeff, coeff_a, coeff_b, coeffs, grade, grade_a, grade_b, id, id_a, id_b, j, l, len, len1, results, sign;
    coeffs = {};
    for (j = 0, len = a.length; j < len; j++) {
      [id_a, coeff_a, grade_a] = a[j];
      for (l = 0, len1 = b.length; l < len1; l++) {
        [id_b, coeff_b, grade_b] = b[l];
        id = id_a ^ id_b;
        grade = grade_a + grade_b;
        if (this.grade(id) === grade) {
          sign = this.antisymmetric_sign(id_a, id_b) * this.metric_sign(id_a, id_b);
          coeff = sign * coeff_a * coeff_b;
          if (coeffs[id] != null) {
            coeffs[id][0] += coeff;
          } else {
            coeffs[id] = [coeff, grade];
          }
        }
      }
    }
    results = [];
    for (id in coeffs) {
      [coeff, grade] = coeffs[id];
      if (coeff !== 0) {
        results.push([id, coeff, grade]);
      }
    }
    return results;
  }

  inverse(a) {
    var a_reverse, coeff, denom, denom_mv, grade, id, j, l, len, len1, results;
    a_reverse = this.reverse(a);
    denom_mv = this.gp(a, a_reverse);
    denom = 0;
    for (j = 0, len = denom_mv.length; j < len; j++) {
      [id, coeff, grade] = denom_mv[j];
      if (id === 0) {
        denom = coeff;
        break;
      }
    }
    if (denom === 0) {
      throw new Error("multivector is not invertible (denominator is zero).");
    }
    results = [];
    for (l = 0, len1 = a_reverse.length; l < len1; l++) {
      [id, coeff, grade] = a_reverse[l];
      results.push([id, coeff / denom, grade]);
    }
    return results;
  }

};
