// Generated by CoffeeScript 2.7.0
var sph_ga;

sph_ga = (function() {
  class sph_ga {
    constructor(metric, options = {}) {
      var point;
      this.n = metric.length;
      this.is_conformal = !!options.conformal;
      if (Array.isArray(metric[0])) {
        [this.is_orthonormal, this.is_quasi_diagonal, this.null_vectors] = this.full_metric_properties(metric, this.n);
      } else {
        [this.is_orthonormal, this.is_quasi_diagonal, this.null_vectors] = this.flat_metric_properties(metric, this.n);
        metric = this.flat_metric_to_full(metric, this.n);
        if (this.is_conformal) {
          metric[this.n - 2][this.n - 1] = -1;
          metric[this.n - 1][this.n - 2] = -1;
        }
      }
      this.metric = metric;
      this.pseudoscalar_id = (1 << this.n) - 1;
      if (this.is_conformal) {
        this.eo_bit_index = this.n - 2;
        this.ei_bit_index = this.n - 1;
        this.eo_id = 1 << this.eo_bit_index;
        this.ei_id = 1 << this.ei_bit_index;
        this.eo_index = this.eo_bit_index + 1;
        this.ei_index = this.ei_bit_index + 1;
        this.eo = function(coeff) {
          return [[this.eo_id, coeff, 1]];
        };
        this.ei = function(coeff) {
          return [[this.ei_id, coeff, 1]];
        };
        point = function(euclidean_coeffs) {
          var ei_coeff;
          ei_coeff = 0.5 * this.array_sum(this.array_product(euclidean_coeffs));
          return this.vector([0].concat(euclidean_coeffs).concat([1, ei_coeff]));
        };
      }
    }

    flat_metric_properties(metric, n) {
      var a, is_orthonormal, k, len, null_vectors;
      null_vectors = 0;
      is_orthonormal = true;
      for (k = 0, len = metric.length; k < len; k++) {
        a = metric[k];
        if (a) {
          if (!(a === 1 || a === -1)) {
            is_orthonormal = false;
          }
        } else {
          null_vectors += 1;
          is_orthonormal = false;
        }
      }
      return [is_orthonormal, true, null_vectors];
    }

    full_metric_properties(metric, n) {
      var diagonal, i, is_orthonormal, is_quasi_diagonal, is_symmetric, j, k, l, m, null_vectors, o, ref, ref1, ref2, ref3, ref4;
      null_vectors = 0;
      is_symmetric = true;
      is_orthonormal = true;
      is_quasi_diagonal = true;
// check symmetry
      for (i = k = 0, ref = n; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        for (j = l = ref1 = i + 1, ref2 = n; (ref1 <= ref2 ? l < ref2 : l > ref2); j = ref1 <= ref2 ? ++l : --l) {
          if (metric[i][j] !== metric[j][i]) {
            return [false, false, null_vectors];
          }
        }
      }
      for (i = m = 0, ref3 = n; (0 <= ref3 ? m < ref3 : m > ref3); i = 0 <= ref3 ? ++m : --m) {
        diagonal = metric[i][i];
        if (!diagonal) {
          null_vectors += 1;
          is_orthonormal = false;
          is_quasi_diagonal = false;
          continue;
        }
        if (!(diagonal === 1 || diagonal === -1)) {
          is_orthonormal = false;
        }
        for (j = o = 0, ref4 = n; (0 <= ref4 ? o < ref4 : o > ref4); j = 0 <= ref4 ? ++o : --o) {
          if (i === j) {
            next;
          }
          if (metric[i][j] !== 0) {
            is_quasi_diagonal = false;
            is_orthonormal = false;
            break;
          }
        }
        if (!(is_quasi_diagonal || is_orthonormal)) {
          break;
        }
      }
      return [is_orthonormal, is_quasi_diagonal, null_vectors];
    }

    flat_metric_to_full(metric, n) {
      var a, b, i, k, ref;
      a = Array(n);
      for (i = k = 0, ref = n; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        b = Array(n).fill(0);
        b[i] = metric[i];
        a[i] = b;
      }
      return a;
    }

    array_product(a) {
      return a.reduce((function(b, a) {
        return a * b;
      }), 1);
    }

    array_sum(a) {
      return a.reduce((function(b, a) {
        return a + b;
      }), 1);
    }

    basis_blade(i, coeff) {
      if (i) {
        return [1 << (i - 1), coeff, 1];
      } else {
        return [0, coeff, 0];
      }
    }

    basis(i, coeff) {
      return [this.basis_blade(i, (coeff != null ? coeff : 1))];
    }

    vector(coeffs) {
      var a, i, k, len, results;
      results = [];
      for (i = k = 0, len = coeffs.length; k < len; i = ++k) {
        a = coeffs[i];
        if (a) {
          results.push(this.basis_blade(i, a));
        }
      }
      return results;
    }

    s(coeff) {
      return [[0, coeff, 0]];
    }

    id_from_indices(indices) {
      return indices.reduce((function(id, i) {
        return id |= 1 << (i - 1);
      }), 0);
    }

    blade(indices, coeff) {
      if (indices[0]) {
        return [this.id_from_indices(indices), coeff, indices.length];
      } else {
        return [this.id_from_indices(indices.slice(1)), coeff, indices.length - 1];
      }
    }

    mv(terms) {
      var coeff, indices, k, len, results;
      results = [];
      for (k = 0, len = terms.length; k < len; k++) {
        [indices, coeff] = terms[k];
        results.push(this.blade(indices, coeff));
      }
      return results;
    }

    map_grade_factor(a, f) {
      var coeff, grade, id, k, len, results;
      results = [];
      for (k = 0, len = a.length; k < len; k++) {
        [id, coeff, grade] = a[k];
        results.push([id, coeff * f(grade), grade]);
      }
      return results;
    }

    involute(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** grade;
      });
    }

    conjugate(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade + 1)) >> 1);
      });
    }

    reverse(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade - 1)) >> 1);
      });
    }

    add(a, b) {
      return this.combine(a, b, 1);
    }

    subtract(a, b) {
      return this.combine(a, b, -1);
    }

    sp(a, b) {
      return this.gp(this.gp(a, b), this.inverse(a));
    }

    pseudoscalar() {
      var ref;
      return [
        this.blade((function() {
          var results = [];
          for (var k = 1, ref = this.n; 1 <= ref ? k <= ref : k >= ref; 1 <= ref ? k++ : k--){ results.push(k); }
          return results;
        }).apply(this),
        1)
      ];
    }

    coeffs_add(coeffs, id, coeff, grade) {
      if (coeffs[id] != null) {
        return coeffs[id][0] += coeff;
      } else {
        return coeffs[id] = [coeff, grade];
      }
    }

    coeffs_to_mv(coeffs) {
      var coeff, grade, id, results;
      results = [];
      for (id in coeffs) {
        [coeff, grade] = coeffs[id];
        if (coeff !== 0) {
          results.push([parseInt(id), coeff, grade]);
        }
      }
      return results;
    }

    grade(a) {
      return a[a.length - 1][2];
    }

    blade_id(a) {
      return a[0];
    }

    blade_coeff(a) {
      return a[1];
    }

    blade_grade(a) {
      return a[2];
    }

    get(a, id) {
      var b, k, len;
      for (k = 0, len = a.length; k < len; k++) {
        b = a[k];
        if (id === b[0]) {
          return b;
        }
      }
    }

    bitcount(a) {
      var b, n;
      if (a in this.bitcount_cache) {
        return this.bitcount_cache[a];
      }
      n = 0;
      b = a;
      while (b !== 0) {
        b &= b - 1;
        n += 1;
      }
      this.bitcount_cache[a] = n;
      return n;
    }

    determinant(matrix) {
      var determinant_generic, n;
      determinant_generic = function(matrix) {
        var det, i, j, k, l, n, ref, ref1, sign, submatrix;
        // Generic solution for larger matrices using Laplace expansion
        n = matrix.length;
        if (n === 1) {
          return matrix[0][0];
        }
        det = 0;
        for (j = k = 0, ref = n; (0 <= ref ? k < ref : k > ref); j = 0 <= ref ? ++k : --k) {
          for (i = l = 1, ref1 = n; (1 <= ref1 ? l < ref1 : l > ref1); i = 1 <= ref1 ? ++l : --l) {
            submatrix = matrix[i].slice(0, j).concat(matrix[i].slice(j + 1));
          }
          sign = j % 2 === 0 ? 1 : -1;
          det += sign * matrix[0][j] * determinant_generic(submatrix);
        }
        return det;
      };
      n = matrix.length;
      // Hardcoded formulas for small matrices
      if (n === 1) {
        return matrix[0][0];
      } else if (n === 2) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      } else if (n === 3) {
        return matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
      } else if (n === 4) {
        return matrix[0][0] * (matrix[1][1] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) + matrix[1][3] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1])) - matrix[0][1] * (matrix[1][0] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0])) + matrix[0][2] * (matrix[1][0] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0])) - matrix[0][3] * (matrix[1][0] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0]) + matrix[1][2] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0]));
      } else {
        return determinant_generic(matrix);
      }
    }

    ep_sign(id_a, id_b) {
      var concatenated, count, i, j, k, l, ref, ref1, ref2, sign, vectors_a, vectors_b;
      vectors_a = this.get_basis_indices(id_a);
      vectors_b = this.get_basis_indices(id_b);
      concatenated = vectors_a.concat(vectors_b);
      // Count the number of inversions (swaps needed to sort the list)
      count = 0;
      for (i = k = 0, ref = concatenated.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        for (j = l = ref1 = i + 1, ref2 = concatenated.length; (ref1 <= ref2 ? l < ref2 : l > ref2); j = ref1 <= ref2 ? ++l : --l) {
          if (concatenated[i] > concatenated[j]) {
            count += 1;
          }
        }
      }
      sign = (count % 2) === 0 ? 1 : -1;
      return sign;
    }

    get_basis_indices(id) {
      var i, indices, k, ref;
      if (id in this.indices_cache) {
        return this.indices_cache[id];
      }
      indices = [];
      for (i = k = 0, ref = this.n; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        if ((id & (1 << i)) !== 0) {
          indices.push(i);
        }
      }
      this.indices_cache[id] = indices;
      return indices;
    }

    count_inversions_sorted(a, b) {
      var i, inversions, j;
      inversions = 0;
      i = 0;
      j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] <= b[j]) {
          i += 1;
        } else {
          inversions += a.length - i;
          j += 1;
        }
      }
      return inversions;
    }

    ip_determinant_metric(id, indices) {
      return this.ip_metric(id, indices);
    }

    ip_full_metric(indices) {
      if (this.is_conformal && ([this.eo_id, this.ei_id].some(function(id) {
        return indices.includes(id);
      }))) {
        // special case: Null vectors in differing blade ids
        return this.ip_metric(this.eo_id | this.ei_id, indices);
      } else {
        return this.ip_metric(0, indices);
      }
    }

    ip(a, b) {
      var coeff, coeff_a, coeff_b, coeffs, grade, grade_a, grade_b, i, id, id_a, id_b, id_c, indices_a, k, l, len, len1, sign;
      coeffs = {};
      if (1 === a.length) { // scalar ⋅ b
        if (!a[0][0]) {
          return (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = b.length; k < len; k++) {
              [id, coeff, grade] = b[k];
              results.push([id, coeff * a[0][1] * this.ip_metric(id), grade]);
            }
            return results;
          }).call(this);
        }
      }
      if (1 === b.length) { // a ⋅ scalar
        if (!b[0][0]) {
          return (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = a.length; k < len; k++) {
              [id, coeff, grade] = a[k];
              results.push([id, coeff * b[0][1] * this.ip_metric(id), grade]);
            }
            return results;
          }).call(this);
        }
      }
      for (k = 0, len = a.length; k < len; k++) {
        [id_a, coeff_a, grade_a] = a[k];
        indices_a = this.get_basis_indices(id_a);
        for (l = 0, len1 = b.length; l < len1; l++) {
          [id_b, coeff_b, grade_b] = b[l];
          if (grade_a <= grade_b && (id_a & id_b) === id_a) {
            if (id_b === id_a) {
              if (1 === grade_b && 1 === grade_a) { // e_i ⋅ e_i
                i = indices_a[0];
                this.coeffs_add(coeffs, id_a, this.metric[i][i], 1); // a ⋅ a
              } else {
                this.coeffs_add(coeffs, id_a, coeff_a * coeff_b * ip_determinant_metric(id_a, indices_a), grade_a); // a ⋅ b
              }
            } else {
              id_c = id_b & ~id_a;
              sign = (-1) ** count_inversions_sorted(indices_a, this.get_basis_indices(id_c));
              coeff = coeff_a * coeff_b * sign * ip_full_metric(indices_c);
              this.coeffs_add(coeffs, id_a, coeff, grade_b - grade_a);
            }
          }
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    ep(a, b) {
      var coeff, coeff_a, coeff_b, coeffs, grade_a, grade_b, id_a, id_b, id_c, k, l, len, len1;
      coeffs = {};
      for (k = 0, len = a.length; k < len; k++) {
        [id_a, coeff_a, grade_a] = a[k];
        for (l = 0, len1 = b.length; l < len1; l++) {
          [id_b, coeff_b, grade_b] = b[l];
          if ((id_a & id_b) !== 0) {
            continue;
          }
          id_c = id_a | id_b;
          coeff = coeff_a * coeff_b * this.ep_sign(id_a, idb);
          if (coeff !== 0) {
            this.coeffs_add(coeffs, id_c, coeff, grade_a + grade_b);
          }
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    gp(a, b) {
      return this.s(0);
    }

    combine(a, b, scalar = 1) {
      var coeff, coeffs, grade, id, k, l, len, len1, results;
      coeffs = {};
      for (k = 0, len = a.length; k < len; k++) {
        [id, coeff, grade] = a[k];
        coeffs[id] = [coeff, grade];
      }
      for (l = 0, len1 = b.length; l < len1; l++) {
        [id, coeff, grade] = b[l];
        if (coeffs[id] != null) {
          coeffs[id][0] += coeff * scalar;
        } else {
          coeffs[id] = [coeff * scalar, grade];
        }
      }
      results = [];
      for (id in coeffs) {
        [coeff, grade] = coeffs[id];
        if (coeff !== 0) {
          results.push([parseInt(id), coeff, grade]);
        }
      }
      return results;
    }

    inverse(a) {
      var a_reverse, coeff, denom, denom_mv, grade, id, k, l, len, len1, results;
      a_reverse = this.reverse(a);
      denom_mv = this.gp(a, a_reverse);
      denom = 0;
      for (k = 0, len = denom_mv.length; k < len; k++) {
        [id, coeff, grade] = denom_mv[k];
        if (id === 0) {
          denom = coeff;
          break;
        }
      }
      if (denom === 0) {
        throw new Error("multivector is not invertible (denominator is zero).");
      }
      results = [];
      for (l = 0, len1 = a_reverse.length; l < len1; l++) {
        [id, coeff, grade] = a_reverse[l];
        results.push([parseInt(id), coeff / denom, grade]);
      }
      return results;
    }

  };

  sph_ga.prototype.bitcount_cache = {};

  sph_ga.prototype.indices_cache = {};

  return sph_ga;

}).call(this);

if (typeof module !== "undefined" && module.exports) {
  module.exports = sph_ga;
} else {
  window.sph_ga = sph_ga;
}
