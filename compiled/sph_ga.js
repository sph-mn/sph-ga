// Generated by CoffeeScript 2.7.0
var sph_ga,
  indexOf = [].indexOf;

sph_ga = (function() {
  var determinant_generic;

  class sph_ga {
    constructor(metric, options = {}) {
      var null_vector_start, point, ref, ref1;
      this.n = metric.length;
      this.is_conformal = !!options.conformal;
      if (!Array.isArray(metric[0])) {
        if (this.is_conformal) {
          this.n += 2;
          metric.push(0, 0);
        }
        metric = this.flat_metric_to_full(metric, this.n);
        if (this.is_conformal) {
          metric[this.n - 1][this.n - 2] = -1;
          metric[this.n - 2][this.n - 1] = -1;
        }
      }
      [this.is_symmetric, this.is_diagonal, this.null_vectors] = this.metric_properties(metric, this.n);
      if (!this.is_symmetric) {
        throw new Error("the metric must be symmetric in the non-null part");
      }
      if (this.is_conformal) {
        if (2 !== this.null_vectors) {
          throw new Error("only two null vectors are allowed with \"conformal: true\". use a custom metric instead");
        }
        if (!this.is_diagonal) {
          throw new Error("only diagonal metrics are allowed with \"conformal: true\". use a custom metric instead");
        }
      }
      if (this.null_vectors) {
        null_vector_start = this.n - this.null_vectors;
        this.id_null = this.id_from_indices((function() {
          var results = [];
          for (var l = ref = null_vector_start + 1, ref1 = this.n; ref <= ref1 ? l <= ref1 : l >= ref1; ref <= ref1 ? l++ : l--){ results.push(l); }
          return results;
        }).apply(this));
      }
      this.pseudoscalar_id = (1 << this.n) - 1;
      this.metric = metric;
      if (this.is_diagonal) {
        this.ip_metric = function(indices) {
          var i;
          return this.array_product((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = indices.length; l < len; l++) {
              i = indices[l];
              results.push(this.metric[i][i]);
            }
            return results;
          }).call(this));
        };
      } else {
        this.ip_metric = function(indices) {
          var i, j;
          if (!indices.length) {
            return 1;
          }
          return this.determinant((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = indices.length; l < len; l++) {
              i = indices[l];
              results.push((function() {
                var len1, o, results1;
                results1 = [];
                for (o = 0, len1 = indices.length; o < len1; o++) {
                  j = indices[o];
                  results1.push(this.metric[i][j]);
                }
                return results1;
              }).call(this));
            }
            return results;
          }).call(this));
        };
      }
      if (this.is_conformal) {
        this.no_bit_index = this.n - 2;
        this.ni_bit_index = this.n - 1;
        this.no_id = 1 << this.eo_bit_index;
        this.ni_id = 1 << this.ei_bit_index;
        this.no_index = this.no_bit_index + 1;
        this.ni_index = this.ni_bit_index + 1;
        this.no = function(coeff) {
          return [[this.no_id, coeff, 1]];
        };
        this.ni = function(coeff) {
          return [[this.ni_id, coeff, 1]];
        };
        point = function(euclidean_coeffs) {
          var ni_coeff;
          ni_coeff = 0.5 * this.array_sum(this.array_product(euclidean_coeffs));
          return this.vector([0].concat(euclidean_coeffs).concat([1, ni_coeff]));
        };
      }
    }

    add(a, b) {
      return this.combine(a, b, 1);
    }

    array_diff(a, b) {
      return a.filter(function(c) {
        return !(indexOf.call(b, c) >= 0);
      });
    }

    array_product(a) {
      return a.reduce((function(b, a) {
        return a * b;
      }), 1);
    }

    array_sum(a) {
      return a.reduce((function(b, a) {
        return a + b;
      }), 0);
    }

    basis_blade(i, coeff) {
      if (i) {
        return [1 << (i - 1), coeff, 1];
      } else {
        return [0, coeff, 0];
      }
    }

    basis(i, coeff) {
      return [this.basis_blade(i, (coeff != null ? coeff : 1))];
    }

    blade_coeff(a) {
      return a[1];
    }

    blade_grade(a) {
      return a[2];
    }

    blade_id(a) {
      return a[0];
    }

    coeffs_add(coeffs, id, coeff, grade) {
      if (coeffs[id] != null) {
        return coeffs[id][0] += coeff;
      } else {
        return coeffs[id] = [coeff, grade];
      }
    }

    conjugate(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade + 1)) >> 1);
      });
    }

    get(a, id) {
      var b, l, len;
      for (l = 0, len = a.length; l < len; l++) {
        b = a[l];
        if (id === b[0]) {
          return b;
        }
      }
    }

    grade(a) {
      return a[a.length - 1][2];
    }

    id_from_bit_indices(indices) {
      return indices.reduce((function(id, i) {
        return id |= 1 << i;
      }), 0);
    }

    id_from_indices(indices) {
      return indices.reduce((function(id, i) {
        return id |= 1 << (i - 1);
      }), 0);
    }

    involute(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** grade;
      });
    }

    map_grade_factor(a, f) {
      var coeff, grade, id, l, len, results;
      results = [];
      for (l = 0, len = a.length; l < len; l++) {
        [id, coeff, grade] = a[l];
        results.push([id, coeff * f(grade), grade]);
      }
      return results;
    }

    mv(terms) {
      var coeff, indices, l, len, results;
      results = [];
      for (l = 0, len = terms.length; l < len; l++) {
        [indices, coeff] = terms[l];
        results.push(this.blade(indices, coeff));
      }
      return results;
    }

    negate(a) {
      return this.scale(a, -1);
    }

    pseudoscalar() {
      var ref;
      return [
        this.blade((function() {
          var results = [];
          for (var l = 1, ref = this.n; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--){ results.push(l); }
          return results;
        }).apply(this),
        1)
      ];
    }

    reverse(a) {
      return this.map_grade_factor(a, function(grade) {
        return (-1) ** ((grade * (grade - 1)) >> 1);
      });
    }

    scale(mv, a) {
      var coeff, grade, id, l, len, results;
      results = [];
      for (l = 0, len = mv.length; l < len; l++) {
        [id, coeff, grade] = mv[l];
        results.push([id, coeff * a, grade]);
      }
      return results;
    }

    s(coeff) {
      return [[0, coeff, 0]];
    }

    sp(a, b) {
      return this.gp(this.gp(a, b), this.inverse(a));
    }

    subtract(a, b) {
      return this.combine(a, b, -1);
    }

    vector(coeffs) {
      var a, i, l, len, results;
      results = [];
      for (i = l = 0, len = coeffs.length; l < len; i = ++l) {
        a = coeffs[i];
        if (a) {
          results.push(this.basis_blade(i, a));
        }
      }
      return results;
    }

    blade(indices, coeff) {
      if (indices[0]) {
        return [this.id_from_indices(indices), coeff, indices.length];
      } else {
        return [this.id_from_indices(indices.slice(1)), coeff, indices.length - 1];
      }
    }

    coeffs_to_mv(coeffs) {
      var a, coeff, grade, id;
      a = (function() {
        var results;
        results = [];
        for (id in coeffs) {
          [coeff, grade] = coeffs[id];
          if (coeff !== 0) {
            results.push([parseInt(id), coeff, grade]);
          }
        }
        return results;
      })();
      if (a.length) {
        return a;
      } else {
        return [[0, 0, 0]];
      }
    }

    id_indices(id) {
      var a, l, len, ref, results;
      if (id) {
        ref = this.id_bit_indices(id);
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          a = ref[l];
          results.push(1 + a);
        }
        return results;
      } else {
        return [0];
      }
    }

    id_bit_indices(id) {
      var a, i;
      if (id in this.id_bit_indices_cache) {
        return this.id_bit_indices_cache[id];
      }
      a = (function() {
        var l, ref, results;
        results = [];
        for (i = l = 0, ref = this.n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          if (id & (1 << i)) {
            results.push(i);
          }
        }
        return results;
      }).call(this);
      this.id_bit_indices_cache[id] = a;
      return a;
    }

    flat_metric_to_full(metric, n) {
      var a, b, i, l, ref;
      a = Array(n);
      for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        b = Array(n).fill(0);
        b[i] = metric[i];
        a[i] = b;
      }
      return a;
    }

    metric_properties(metric, n) {
      var di, first_zero, i, is_diagonal, j, k, l, null_vectors, o, p, ref, ref1, ref2, ref3, ref4, ref5;
      null_vectors = 0;
      first_zero = n;
      is_diagonal = true;
      for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        di = metric[i][i];
        if (di === 0) {
          null_vectors += 1;
          if (first_zero === n) {
            first_zero = i;
          }
        } else {
          if (first_zero < n || ((ref1 = !di) === 1 || ref1 === (-1))) {
            is_diagonal = false;
            break;
          }
        }
        for (j = o = ref2 = i + 1, ref3 = n; (ref2 <= ref3 ? o < ref3 : o > ref3); j = ref2 <= ref3 ? ++o : --o) {
          if (i < first_zero) {
            if (metric[i][j] !== metric[j][i]) {
              return [false, false, null_vectors];
            }
            if (metric[i][j] !== 0) {
              is_diagonal = false;
              break;
            }
          }
        }
        if (!is_diagonal) {
          break;
        }
      }
      for (k = p = ref4 = first_zero, ref5 = n; (ref4 <= ref5 ? p < ref5 : p > ref5); k = ref4 <= ref5 ? ++p : --p) {
        if (metric[k][k] !== 0) {
          return [false, false, null_vectors];
        }
      }
      return [true, is_diagonal, null_vectors];
    }

    id_grade(a) {
      var b, n;
      if (a in this.id_grade_cache) {
        return this.id_grade_cache[a];
      }
      n = 0;
      b = a;
      while (b !== 0) {
        b &= b - 1;
        n += 1;
      }
      this.id_grade_cache[a] = n;
      return n;
    }

    determinant(matrix) {
      var n;
      n = matrix.length;
      if (1 === n) {
        return matrix[0][0];
      } else if (2 === n) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      } else if (3 === n) {
        return matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
      } else if (4 === n) {
        return matrix[0][0] * (matrix[1][1] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) + matrix[1][3] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1])) - matrix[0][1] * (matrix[1][0] * (matrix[2][2] * matrix[3][3] - matrix[2][3] * matrix[3][2]) - matrix[1][2] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0])) + matrix[0][2] * (matrix[1][0] * (matrix[2][1] * matrix[3][3] - matrix[2][3] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][3] - matrix[2][3] * matrix[3][0]) + matrix[1][3] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0])) - matrix[0][3] * (matrix[1][0] * (matrix[2][1] * matrix[3][2] - matrix[2][2] * matrix[3][1]) - matrix[1][1] * (matrix[2][0] * matrix[3][2] - matrix[2][2] * matrix[3][0]) + matrix[1][2] * (matrix[2][0] * matrix[3][1] - matrix[2][1] * matrix[3][0]));
      } else {
        return this.determinant_generic(matrix, n);
      }
    }

    for_each_combination(array, n, f) {
      var generate;
      generate = function(prefix, rest, k, i) {
        var first;
        if (k === 0) {
          f(prefix, i);
          return i + 1;
        }
        if (rest.length === 0) {
          return i;
        }
        [first, ...rest] = rest;
        i = generate(prefix.concat([first]), rest, k - 1, i);
        return generate(prefix, rest, k, i);
      };
      return generate([], array, n, 0);
    }

    sign_sorted(a, b) {
      var c, i, j;
      c = 0;
      i = 0;
      j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] <= b[j]) {
          i += 1;
        } else {
          c += a.length - i;
          j += 1;
        }
      }
      return (-1) ** c;
    }

    sign(indices) {
      var c, i, j, l, o, ref, ref1, ref2;
      c = 0;
      for (i = l = 0, ref = indices.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        for (j = o = ref1 = i + 1, ref2 = indices.length; (ref1 <= ref2 ? o < ref2 : o > ref2); j = ref1 <= ref2 ? ++o : --o) {
          if (indices[i] > indices[j]) {
            c += 1;
          }
        }
      }
      return (-1) ** c;
    }

    ip(a, b) {
      var coeff_a, coeff_b, coeffs, grade_a, grade_b, id_a, id_a_e, id_a_n, id_b, id_b_e, id_b_n, id_c, indices_a, indices_b, indices_c, l, len, len1, m, o, sign;
      coeffs = {};
      if (1 === a.length && !a[0][0]) {
        if (1 === b.length && !b[0][0]) {
          return [[0, a[0][1] * b[0][1], 0]];
        } else {
          return this.null_scalar;
        }
      } else if (1 === b.length && !b[0][0]) {
        return this.null_scalar;
      }
      for (l = 0, len = a.length; l < len; l++) {
        [id_a, coeff_a, grade_a] = a[l];
        indices_a = this.id_bit_indices(id_a);
        id_a_e = id_a & ~this.id_null;
        id_a_n = id_a & this.id_null;
        for (o = 0, len1 = b.length; o < len1; o++) {
          [id_b, coeff_b, grade_b] = b[o];
          if (id_a === id_b) {
            if (m = this.ip_metric(indices_a)) {
              this.coeffs_add(coeffs, 0, coeff_a * coeff_b * m, 0);
            }
            continue;
          }
          id_b_e = id_b & ~this.id_null;
          id_b_n = id_b & this.id_null;
          indices_b = this.id_bit_indices(id_b);
          if (id_a_n || id_b_n) {
            this.for_each_combination(indices_b, indices_a.length, (indices_c, j) => {
              var i, id_c, p, ref, sign;
              sign = (-1) ** j;
              m = 1;
              for (i = p = 0, ref = indices_a.length; (0 <= ref ? p < ref : p > ref); i = 0 <= ref ? ++p : --p) {
                m *= this.metric[indices_a[i]][indices_c[i]];
              }
              if (!m) {
                return;
              }
              id_c = this.id_from_bit_indices(this.array_diff(indices_b, indices_c));
              return this.coeffs_add(coeffs, id_c, coeff_a * coeff_b * sign * m, this.id_grade(id_c));
            });
          } else if ((id_a_e || id_b_e) && grade_a <= grade_b && id_a_e === (id_b_e & id_a_e)) {
            id_c = id_a_e ^ id_b_e;
            indices_c = this.id_bit_indices(id_c);
            if (m = this.ip_metric(indices_c)) {
              sign = this.sign_sorted(indices_a, indices_c);
              this.coeffs_add(coeffs, id_c, coeff_a * coeff_b * sign * m, grade_b - grade_a);
            }
          }
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    ep(a, b) {
      var coeff_a, coeff_b, coeffs, grade_a, grade_b, id, id_a, id_b, indices_a, l, len, len1, o, sign;
      coeffs = {};
      for (l = 0, len = a.length; l < len; l++) {
        [id_a, coeff_a, grade_a] = a[l];
        indices_a = this.id_bit_indices(id_a);
        for (o = 0, len1 = b.length; o < len1; o++) {
          [id_b, coeff_b, grade_b] = b[o];
          if (!(!(id_a & id_b))) {
            continue;
          }
          id = id_a | id_b;
          if (!id) {
            continue;
          }
          sign = id_b ? this.sign_sorted(indices_a, this.id_bit_indices(id_b)) : 1;
          this.coeffs_add(coeffs, id, sign * coeff_a * coeff_b, grade_a + grade_b);
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    gp(a, b) {
      var changed, coeff, coeff_a, coeff_b, coeffs, factor, grade_a, grade_b, i, id_a, id_b, id_c, indices_a, indices_ab, indices_c, j, l, len, len1, m, o, sign;
      coeffs = {};
      for (l = 0, len = a.length; l < len; l++) {
        [id_a, coeff_a, grade_a] = a[l];
        indices_a = this.id_bit_indices(id_a);
        for (o = 0, len1 = b.length; o < len1; o++) {
          [id_b, coeff_b, grade_b] = b[o];
          indices_ab = indices_a.concat(this.id_bit_indices(id_b));
          indices_c = indices_ab.slice().sort();
          sign = this.sign(indices_ab);
          coeff = coeff_a * coeff_b;
          factor = 1;
          changed = true;
          while (changed) { // distinct-pair merging
            changed = false;
            i = 0;
            while (i < indices_c.length) {
              j = i + 1;
              while (j < indices_c.length) {
                if (indices_c[i] !== indices_c[j]) {
                  m = this.metric[indices_c[i]][indices_c[j]];
                  if (m !== 0) {
                    factor *= m;
                    indices_c.splice(j, 1);
                    indices_c.splice(i, 1);
                    changed = true;
                    break;
                  }
                }
                j += 1;
              }
              if (changed) {
                break;
              }
              if (!changed) {
                i += 1;
              }
            }
          }
          changed = true;
          while (changed) { // identical-pair merging
            changed = false;
            i = 0;
            while (i < indices_c.length) {
              j = i + 1;
              while (j < indices_c.length) {
                if (indices_c[i] === indices_c[j]) {
                  m = this.metric[indices_c[i]][indices_c[i]];
                  factor *= m;
                  indices_c.splice(j, 1);
                  indices_c.splice(i, 1);
                  changed = true;
                  break;
                }
                j += 1;
              }
              if (changed) {
                break;
              }
              if (!changed) {
                i += 1;
              }
            }
          }
          coeff *= factor * sign;
          if (!coeff) {
            continue;
          }
          id_c = this.id_from_bit_indices(indices_c);
          this.coeffs_add(coeffs, id_c, coeff, grade_a + grade_b);
        }
      }
      return this.coeffs_to_mv(coeffs);
    }

    combine(a, b, scalar = 1) {
      var c, coeff, coeffs, grade, id, l, len, len1, o;
      coeffs = {};
      for (l = 0, len = a.length; l < len; l++) {
        [id, coeff, grade] = a[l];
        coeffs[id] = [coeff, grade];
      }
      for (o = 0, len1 = b.length; o < len1; o++) {
        [id, coeff, grade] = b[o];
        if (coeffs[id] != null) {
          coeffs[id][0] += coeff * scalar;
        } else {
          coeffs[id] = [coeff * scalar, grade];
        }
      }
      c = (function() {
        var results;
        results = [];
        for (id in coeffs) {
          [coeff, grade] = coeffs[id];
          if (coeff !== 0) {
            results.push([parseInt(id), coeff, grade]);
          }
        }
        return results;
      })();
      if (c.length) {
        return c;
      } else {
        return this.null_scalar;
      }
    }

    inverse(a) {
      var a_reverse, coeff, denom, denom_mv, grade, id, l, len, len1, o, results;
      a_reverse = this.reverse(a);
      denom_mv = this.gp(a, a_reverse);
      denom = 0;
      for (l = 0, len = denom_mv.length; l < len; l++) {
        [id, coeff, grade] = denom_mv[l];
        if (id === 0) {
          denom = coeff;
          break;
        }
      }
      if (denom === 0) {
        throw new Error("multivector is not invertible (denominator is zero).");
      }
      results = [];
      for (o = 0, len1 = a_reverse.length; o < len1; o++) {
        [id, coeff, grade] = a_reverse[o];
        results.push([parseInt(id), coeff / denom, grade]);
      }
      return results;
    }

    blade_to_string(a) {
      var base, coeff, grade, id;
      [id, coeff, grade] = a;
      if (id) {
        base = "e" + this.id_bit_indices(id).map(function(b) {
          return b + 1;
        }).join("_");
        if (1 === coeff) {
          return base;
        } else {
          return coeff + base;
        }
      } else {
        return coeff;
      }
    }

    mv_to_string(a) {
      var b;
      return ((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = a.length; l < len; l++) {
          b = a[l];
          results.push(this.blade_to_string(b));
        }
        return results;
      }).call(this)).join(" + ");
    }

    blade_from_string(a) {
      var coeff, id, indices, left_number, letters, match, n, result, right_numbers;
      match = a.match(/^(?:(\d+(?:\.\d+)?))?([a-z]+)?(?:([\d_]+))?$/);
      if (!match) {
        return null;
      }
      left_number = match[1] != null ? parseFloat(match[1]) : null;
      letters = match[2] != null ? match[2] : null;
      right_numbers = match[3] != null ? (function() {
        var l, len, ref, results;
        ref = match[3].split("_");
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          n = ref[l];
          results.push(parseInt(n));
        }
        return results;
      })() : null;
      result = [];
      coeff = left_number != null ? left_number : 1;
      indices = right_numbers != null ? right_numbers : [];
      if (letters != null) {
        switch (letters) {
          case "no":
            id = c3.no_id;
            break;
          case "ni":
            id = c3.ni_id;
            break;
          default:
            id = this.id_from_indices(right_numbers);
        }
      } else {
        id = 0;
      }
      return [id, coeff, this.id_grade(id)];
    }

    mv_from_string(a) {
      var b, l, len, ref, results;
      ref = a.split(" + ");
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        b = ref[l];
        results.push(this.blade_from_string(b));
      }
      return results;
    }

  };

  sph_ga.prototype.id_bit_indices_cache = {};

  sph_ga.prototype.id_grade_cache = {};

  sph_ga.prototype.null_scalar = [[0, 0, 0]];

  determinant_generic = function(a, n) {
    var b, c, i, j, l, o, ref, ref1, sign;
    if (n === 1) {
      return a[0][0];
    }
    b = 0;
    for (j = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); j = 0 <= ref ? ++l : --l) {
      for (i = o = 1, ref1 = n; (1 <= ref1 ? o < ref1 : o > ref1); i = 1 <= ref1 ? ++o : --o) {
        c = a[i].slice(0, j).concat(a[i].slice(j + 1));
      }
      sign = 0 === j % 2 ? 1 : -1;
      b += sign * a[0][j] * determinant_generic(c);
    }
    return b;
  };

  return sph_ga;

}).call(this);

if (typeof module !== "undefined" && module.exports) {
  module.exports = sph_ga;
} else {
  window.sph_ga = sph_ga;
}
