// Generated by CoffeeScript 2.7.0
var c3, call_with_mv_string, custom_test_runner_class, ref, sph_ga, test_data_generator_class, test_runner, test_runner_class;

sph_ga = require("./ga.coffee");

test_runner_class = class test_runner_class {
  // this class executes automated tests based on an array format.
  is_string(a) {
    return typeof a === "string";
  }

  to_json(a) {
    return JSON.stringify(a).replace(/,(?=\S)/g, ", ");
  }

  is_plain_object(a) {
    return (a != null) && typeof a === "object" && a.constructor === Object;
  }

  any_to_array(a) {
    if (Array.isArray(a)) {
      return a;
    } else {
      return [a];
    }
  }

  object_merge(a, b) {
    var k, v;
    for (k in b) {
      v = b[k];
      if (this.is_plain_object(v) && this.is_plain_object(a[k])) {
        a[k] = this.object_merge(a[k], v);
      } else {
        a[k] = v;
      }
    }
    return a;
  }

  report_compact_failure_strings(inp, exp, out) {
    var a;
    return [
      ((function() {
        var l,
      len,
      results1;
        results1 = [];
        for (l = 0, len = inp.length; l < len; l++) {
          a = inp[l];
          results1.push(this.to_json(a));
        }
        return results1;
      }).call(this)).join(", "),
      this.to_json(exp),
      this.to_json(out)
    ];
  }

  report_compact(results) {
    var exp, exp_string, index, inp, inp_string, l, len, len1, m, name, out, out_string, results1, status, test_results;
    results1 = [];
    for (l = 0, len = results.length; l < len; l++) {
      [name, ...test_results] = results[l];
      process.stdout.write(name);
      for (m = 0, len1 = test_results.length; m < len1; m++) {
        [status, index, name, inp, exp, out] = test_results[m];
        if (status) {
          process.stdout.write(` ${index}`);
        } else {
          [inp_string, exp_string, out_string] = this.report_compact_failure_strings(inp, exp, out);
          process.stdout.write([`\n  failure ${name} ${index}`, `inp ${inp_string}`, `exp ${exp_string}`, `out ${out_string}`].join("\n  "));
        }
      }
      results1.push(console.log(""));
    }
    return results1;
  }

  constructor(options) {
    var default_options;
    default_options = {
      reporter: this.report_compact
    };
    this.options = this.object_merge(default_options, options);
    this.options.reporter = this.options.reporter.bind(this);
  }

  execute_tests(tests) {
    var context, exp, exp_string, f, i, inp, l, len, m, name, name_or_context, out, out_string, ref, rest, results, results1, status;
    status = true;
    results1 = [];
    for (l = 0, len = tests.length; l < len; l++) {
      [f, ...rest] = tests[l];
      if (!status) {
        break;
      }
      [name, context] = Array.isArray(f) ? ([name_or_context, f] = f, this.is_string(name_or_context) ? [name_or_context, null] : [f.name, name_or_context]) : [f.name, null];
      results = [name];
      for (i = m = 0, ref = rest.length; m < ref; i = m += 2) {
        inp = this.any_to_array(rest[i]);
        exp = rest[i + 1];
        out = f.apply(context, inp);
        out_string = this.to_json(out);
        exp_string = this.to_json(exp);
        status = out_string === exp_string;
        results.push([status, i / 2, name, inp, exp, out]);
        if (!status) {
          break;
        }
      }
      results1.push(results);
    }
    return results1;
  }

  execute(tests) {
    return this.options.reporter(this.execute_tests(tests));
  }

};

test_data_generator_class = class test_data_generator_class {
  // this class systematically generates blade combinations and multivectors for testing.
  to_json(a) {
    return JSON.stringify(a).replace(/,(?=\S)/g, ", ");
  }

  random_integer(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  random_element(a) {
    return a[Math.floor(Math.random() * a.length)];
  }

  randomize(a) {
    var i, j, l, ref;
    for (i = l = ref = a.length - 1; (ref <= 1 ? l <= 1 : l >= 1); i = ref <= 1 ? ++l : --l) {
      j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  id_type(id) {
    var type;
    if (id & ~this.space.id_null) {
      if (id & this.space.id_null) {
        return type = "en";
      } else {
        return type = "e";
      }
    } else {
      if (id & this.space.id_null) {
        return type = "n";
      } else {
        return type = "s";
      }
    }
  }

  constructor(space) {
    var a, b, g, id, k, l, ref, t, v;
    this.cycled_coeff = this.cycled_sequence([2, 3, 4, 5, 6, 7, 8, 9]);
    this.space = space;
    this.n = space.n;
    this.blade_ids = (function() {
      var l, ref, results1;
      results1 = [];
      for (l = 0, ref = this.n; (0 <= ref ? l <= ref : l >= ref); 0 <= ref ? l++ : l--) {
        results1.push({
          s: [],
          e: [],
          n: [],
          en: []
        });
      }
      return results1;
    }).call(this);
    for (id = l = 0, ref = 2 ** this.n; (0 <= ref ? l < ref : l > ref); id = 0 <= ref ? ++l : --l) {
      g = space.id_grade(id);
      t = this.id_type(id);
      this.blade_ids[g][t].push(id);
    }
    this.blade_id_next = (function() {
      var len, m, ref1, results1;
      ref1 = this.blade_ids;
      results1 = [];
      for (m = 0, len = ref1.length; m < len; m++) {
        a = ref1[m];
        b = {};
        for (k in a) {
          v = a[k];
          b[k] = this.cycled_sequence(v);
        }
        results1.push(b);
      }
      return results1;
    }).call(this);
  }

  cycled_sequence(a) {
    var i;
    i = 0;
    return function() {
      var b;
      b = a[i];
      i += 1;
      i = i < a.length ? i : 0;
      return b;
    };
  }

  blade(grade, type, overlap_id) {
    var id, ids, ids_with_overlap, types;
    // type
    //   s: scalar
    //   e: euclidean
    //   n: null
    //   en: mixed
    //   any: any
    if ("any" === type) {
      types = Object.keys(this.blade_ids[grade]).filter((a) => {
        return this.blade_ids[grade][a].length;
      });
      if (!types.length) {
        return null;
      }
      type = this.random_element(types);
    }
    if (overlap_id) {
      ids = this.blade_ids[grade][type];
      ids_with_overlap = ids.filter(function(a) {
        return a & overlap_id;
      });
      id = this.random_element(ids_with_overlap);
    } else {
      id = this.blade_id_next[grade][type]();
    }
    if (id == null) {
      return null;
    }
    return [this.space.id_indices(id), this.cycled_coeff()];
  }

  derived_blade(blade_a, grade_b, type_b, overlap_type) {
    var blade_b, grade_a, id_a, type_a;
    // overlap_type
    //   0: unspecified overlap
    //   1: partial overlap
    //   2: full overlap
    id_a = this.space.id_from_indices(blade_a[0]);
    type_a = this.id_type(id_a);
    grade_a = this.space.id_grade(id_a);
    switch (overlap_type) {
      case 0:
        return this.blade(grade_b, type_b);
      case 1:
        return this.blade(grade_b, type_b, id_a);
      case 2:
        if (!(grade_a === grade_b && type_a === type_b)) {
          return null;
        }
        blade_b = Array.from(blade_a);
        blade_b[1] = this.cycled_coeff();
        return blade_b;
    }
  }

  mv(config) {
    var a, first, previous, rest;
    // [[grade, type, overlap_type], ...]
    first = this.blade.apply(this, config[0].slice(0, 2));
    rest = config.slice(1);
    previous = first;
    rest = (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = rest.length; l < len; l++) {
        a = rest[l];
        previous = this.derived_blade(previous, a[0], a[1], a[2]);
        if (!previous) {
          break;
        }
        results1.push(previous);
      }
      return results1;
    }).call(this);
    if (rest.length !== (config.length - 1)) {
      return null;
    }
    return [first].concat(rest);
  }

  display_combination_tests() {
    var a, b, combinations, config1, config2, g1, g2, grades1, grades2, l, len, len1, len2, len3, len4, len5, len6, m, mv, n, o, p, q, r, ref, ref1, ref2, s, strings, t1, t2;
    combinations = [];
    ref = [[0, "s"], [1, "e"]];
    for (l = 0, len = ref.length; l < len; l++) {
      [g1, t1] = ref[l];
      ref1 = [[0, "s"], [1, "e"]];
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        [g2, t2] = ref1[m];
        if ("e" === t1 && t2 === t1) {
          continue;
        }
        mv = this.mv([[g1, t1, 0], [g2, t2, 0]]);
        combinations.push([[mv[0]], [mv[1]]]);
      }
    }
    config1 = [[[1], "e"], [[1, 2], "n"], [[2], "en"]];
    config2 = [[[1, 2], "e"], [[1, 2], "n"], [[2, 3], "en"]];
    for (n = 0, len2 = config1.length; n < len2; n++) {
      [grades1, t1] = config1[n];
      for (p = 0, len3 = grades1.length; p < len3; p++) {
        g1 = grades1[p];
        for (q = 0, len4 = config2.length; q < len4; q++) {
          [grades2, t2] = config2[q];
          for (r = 0, len5 = grades2.length; r < len5; r++) {
            g2 = grades2[r];
            ref2 = [0, 2];
            for (s = 0, len6 = ref2.length; s < len6; s++) {
              o = ref2[s];
              mv = this.mv([[g1, t1, 0], [g2, t2, o]]);
              if (!mv) {
                continue;
              }
              combinations.push([[mv[0]], [mv[1]]]);
            }
          }
        }
      }
    }
    mv = this.mv([[3, "en", 0], [1, "e", 1]]);
    combinations.push([[mv[0]], [mv[1]]]);
    combinations.push([this.mv([[1, "any", 0], [1, "any", 0]]), this.mv([[2, "any", 0], [3, "any", 0]])]);
    return strings = (function() {
      var len7, results1, u;
      results1 = [];
      for (u = 0, len7 = combinations.length; u < len7; u++) {
        a = combinations[u];
        a = (function() {
          var len8, results2, w;
          results2 = [];
          for (w = 0, len8 = a.length; w < len8; w++) {
            b = a[w];
            results2.push(this.space.mv_to_string(this.space.mv(b)));
          }
          return results2;
        }).call(this);
        results1.push(console.log(this.to_json(a)));
      }
      return results1;
    }).call(this);
  }

};

custom_test_runner_class = class custom_test_runner_class extends test_runner_class {
  // this converts input/output from and to strings for a compact and easier to manage test specification.
  is_mv(a) {
    return Array.isArray(a) && a.every(function(a) {
      return Array.isArray(a) && 3 === a.length;
    });
  }

  is_mv_config(a) {
    return Array.isArray(a) && a.every(function(a) {
      return Array.isArray(a) && 2 === a.length;
    });
  }

  is_mv_to_string(a) {
    if (this.is_mv_config(a)) {
      return this.space.mv_to_string(this.space.mv(a));
    } else {
      return a;
    }
  }

  constructor(space) {
    super();
    this.space = space;
    this.report_compact_failure_strings = function(inp, exp, out) {
      var a;
      return [
        ((function() {
          var l,
        len,
        results1;
          results1 = [];
          for (l = 0, len = inp.length; l < len; l++) {
            a = inp[l];
            results1.push(this.is_mv_to_string(a));
          }
          return results1;
        }).call(this)).join(" "),
        this.is_mv_to_string(exp),
        out
      ];
    };
  }

};

c3 = new sph_ga([1, 1, 1], {
  conformal: true
});

// new test data is generated when needed.
//gen = new test_data_generator_class c3
//gen.display_combination_tests()
test_runner = new custom_test_runner_class(c3);

call_with_mv_string = function(f) {
  return function(...a) {
    var b;
    return c3.mv_to_string(f.apply(c3, (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = a.length; l < len; l++) {
        b = a[l];
        results1.push(c3.mv_from_string(b));
      }
      return results1;
    })()));
  };
};

test_runner.execute([
  [["ip",
  call_with_mv_string(c3.ip)],
  ["3e4",
  "4e1_3_4"],
  "0",
  ["2",
  "3"],
  "0",
  ["4",
  "5e1"],
  "20e1",
  ["6e2",
  "7"],
  "0",
  ["8e3",
  "9e1"],
  "0",
  ["2e2",
  "3e2"],
  "6",
  ["4e3",
  "5e1_2"],
  "0",
  ["4e2",
  "5e2_3"],
  "20e3",
  ["7e2",
  "8e4"],
  "0",
  ["2e1",
  "3e4_5"],
  "0",
  ["5e3",
  "6e1_4"],
  "0",
  ["8e2",
  "9e1_2_4"],
  "-72e1_4",
  ["3e5",
  "4e1"],
  "0",
  ["6e5",
  "7e1_3"],
  "0",
  ["9e5",
  "2e4"],
  "18",
  ["3e5",
  "4e5"],
  "0",
  ["5e4",
  "6e4_5"],
  "-30e4",
  ["8e4",
  "9e2_4"],
  "0",
  ["6e4_5",
  "7e2"],
  "0",
  ["9e4_5",
  "2e2_3"],
  "0",
  ["4e4_5",
  "5e4"],
  "0",
  ["7e4_5",
  "8e4_5"],
  "0",
  ["3e4_5",
  "4e3_4"],
  "0",
  ["6e4_5",
  "7e2_3_4"],
  "0",
  ["9e1_5",
  "2e3"],
  "0",
  ["4e3_5",
  "5e1_2"],
  "0",
  ["7e2_4",
  "8e5"],
  "0",
  ["2e1_5",
  "3e4_5"],
  "0",
  ["5e3_5",
  "6e1_4"],
  "0",
  ["7e2_4",
  "8e2_4"],
  "0",
  ["9e3_4",
  "2e1_2_5"],
  "0",
  ["4e1_3_5",
  "5e1"],
  "0",
  ["6e1 + 7e4",
  "8e4_5 + 9e2_3_5"],
  "-63e2_3 + -56e4"],
  [
    [
      "id_bit_indices",
      (function(...inp) {
        var i,
      l,
      len,
      results1;
        results1 = [];
        for (l = 0, len = inp.length; l < len; l++) {
          i = inp[l];
          results1.push(c3.id_bit_indices(i));
        }
        return results1;
      })
    ],
    (function() {
      var results1 = [];
      for (var l = 0, ref = 2 ** c3.n; 0 <= ref ? l < ref : l > ref; 0 <= ref ? l++ : l--){ results1.push(l); }
      return results1;
    }).apply(this),
    [[],
    [0],
    [1],
    [0,
    1],
    [2],
    [0,
    2],
    [1,
    2],
    [0,
    1,
    2],
    [3],
    [0,
    3],
    [1,
    3],
    [0,
    1,
    3],
    [2,
    3],
    [0,
    2,
    3],
    [1,
    2,
    3],
    [0,
    1,
    2,
    3],
    [4],
    [0,
    4],
    [1,
    4],
    [0,
    1,
    4],
    [2,
    4],
    [0,
    2,
    4],
    [1,
    2,
    4],
    [0,
    1,
    2,
    4],
    [3,
    4],
    [0,
    3,
    4],
    [1,
    3,
    4],
    [0,
    1,
    3,
    4],
    [2,
    3,
    4],
    [0,
    2,
    3,
    4],
    [1,
    2,
    3,
    4],
    [0,
    1,
    2,
    3,
    4]]
  ],
  [["reverse",
  call_with_mv_string(c3.reverse)],
  "e1",
  "e1",
  "e1_2",
  "-1e1_2",
  "e1_2_3",
  "-1e1_2_3",
  "1 + e1",
  "1 + e1",
  "1 + e1 + e1_2",
  "1 + e1 + -1e1_2",
  "1 + e1 + e2 + e1_2 + e1_3 + e1_2_3",
  "1 + e1 + e2 + -1e1_2 + -1e1_3 + -1e1_2_3"],
  [["involute",
  call_with_mv_string(c3.involute)],
  "e1",
  "-1e1",
  "e1_2",
  "e1_2",
  "e1_2_3",
  "-1e1_2_3"],
  [["conjugate",
  call_with_mv_string(c3.conjugate)],
  "e1",
  "-1e1",
  "e1_2",
  "-1e1_2",
  "e1_2_3",
  "e1_2_3"],
  [["ep",
  call_with_mv_string(c3.ep)],
  ["3e4",
  "4e1_3_4"],
  "0",
  ["2",
  "3"],
  "0",
  ["4",
  "5e1"],
  "20e1",
  ["6e2",
  "7"],
  "42e2",
  ["8e3",
  "9e1"],
  "0",
  ["2e2",
  "3e2"],
  "6",
  ["4e3",
  "5e1_2"],
  "0",
  ["4e2",
  "5e2_3"],
  "20e3",
  ["7e2",
  "8e4"],
  "0",
  ["2e1",
  "3e4_5"],
  "0",
  ["5e3",
  "6e1_4"],
  "0",
  ["8e2",
  "9e1_2_4"],
  "-72e1_4",
  ["3e5",
  "4e1"],
  "0",
  ["6e5",
  "7e1_3"],
  "0",
  ["9e5",
  "2e4"],
  "18",
  ["3e5",
  "4e5"],
  "0",
  ["5e4",
  "6e4_5"],
  "-30e4",
  ["8e4",
  "9e2_4"],
  "0",
  ["6e4_5",
  "7e2"],
  "0",
  ["9e4_5",
  "2e2_3"],
  "0",
  ["4e4_5",
  "5e4"],
  "0",
  ["7e4_5",
  "8e4_5"],
  "0",
  ["3e4_5",
  "4e3_4"],
  "0",
  ["6e4_5",
  "7e2_3_4"],
  "0",
  ["9e1_5",
  "2e3"],
  "0",
  ["4e3_5",
  "5e1_2"],
  "0",
  ["7e2_4",
  "8e5"],
  "0",
  ["2e1_5",
  "3e4_5"],
  "0",
  ["5e3_5",
  "6e1_4"],
  "0",
  ["7e2_4",
  "8e2_4"],
  "0",
  ["9e3_4",
  "2e1_2_5"],
  "0",
  ["4e1_3_5",
  "5e1"],
  "0",
  ["6e1 + 7e4",
  "8e4_5 + 9e2_3_5"],
  "-63e2_3 + -56e4"]
]);
