// Generated by CoffeeScript 2.7.0
var c3, call_with_mv_string, custom_test_runner_class, ep_tests, gp_tests, ip_tests, ref, sph_ga, test_data_generator_class, test_runner, test_runner_class;

sph_ga = require("./ga.coffee");

test_runner_class = class test_runner_class {
  // this class executes automated tests based on an array format.
  is_string(a) {
    return typeof a === "string";
  }

  to_json(a) {
    return JSON.stringify(a).replace(/,(?=\S)/g, ", ");
  }

  is_plain_object(a) {
    return (a != null) && typeof a === "object" && a.constructor === Object;
  }

  any_to_array(a) {
    if (Array.isArray(a)) {
      return a;
    } else {
      return [a];
    }
  }

  object_merge(a, b) {
    var k, v;
    for (k in b) {
      v = b[k];
      if (this.is_plain_object(v) && this.is_plain_object(a[k])) {
        a[k] = this.object_merge(a[k], v);
      } else {
        a[k] = v;
      }
    }
    return a;
  }

  report_compact_failure_strings(inp, exp, out) {
    var a;
    return [
      ((function() {
        var l,
      len,
      results1;
        results1 = [];
        for (l = 0, len = inp.length; l < len; l++) {
          a = inp[l];
          results1.push(this.to_json(a));
        }
        return results1;
      }).call(this)).join(", "),
      this.to_json(exp),
      this.to_json(out)
    ];
  }

  report_compact(results) {
    var exp, exp_string, index, inp, inp_string, l, len, len1, m, name, out, out_string, results1, status, test_results;
    results1 = [];
    for (l = 0, len = results.length; l < len; l++) {
      [name, ...test_results] = results[l];
      process.stdout.write(name);
      for (m = 0, len1 = test_results.length; m < len1; m++) {
        [status, index, name, inp, exp, out] = test_results[m];
        if (status) {
          process.stdout.write(` ${index}`);
        } else {
          [inp_string, exp_string, out_string] = this.report_compact_failure_strings(inp, exp, out);
          process.stdout.write([`\n  failure ${name} ${index}`, `inp ${inp_string}`, `exp ${exp_string}`, `out ${out_string}`].join("\n  "));
        }
      }
      results1.push(console.log(""));
    }
    return results1;
  }

  constructor(options) {
    var default_options;
    default_options = {
      reporter: this.report_compact
    };
    this.options = this.object_merge(default_options, options);
    this.options.reporter = this.options.reporter.bind(this);
  }

  execute_tests(tests) {
    var context, exp, exp_string, f, i, inp, l, len, m, name, name_or_context, out, out_string, ref, rest, results, results1, status;
    status = true;
    results1 = [];
    for (l = 0, len = tests.length; l < len; l++) {
      [f, ...rest] = tests[l];
      if (!status) {
        break;
      }
      [name, context] = Array.isArray(f) ? ([name_or_context, f] = f, this.is_string(name_or_context) ? [name_or_context, null] : [f.name, name_or_context]) : [f.name, null];
      results = [name];
      for (i = m = 0, ref = rest.length; m < ref; i = m += 2) {
        inp = this.any_to_array(rest[i]);
        exp = rest[i + 1];
        out = f.apply(context, inp);
        out_string = this.to_json(out);
        exp_string = this.to_json(exp);
        status = out_string === exp_string;
        results.push([status, i / 2, name, inp, exp, out]);
        if (!status) {
          break;
        }
      }
      results1.push(results);
    }
    return results1;
  }

  execute(tests) {
    return this.options.reporter(this.execute_tests(tests));
  }

};

test_data_generator_class = class test_data_generator_class {
  // this class systematically generates blade combinations and multivectors for testing.
  to_json(a) {
    return JSON.stringify(a).replace(/,(?=\S)/g, ", ");
  }

  random_integer(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  random_element(a) {
    return a[Math.floor(Math.random() * a.length)];
  }

  randomize(a) {
    var i, j, l, ref;
    for (i = l = ref = a.length - 1; (ref <= 1 ? l <= 1 : l >= 1); i = ref <= 1 ? ++l : --l) {
      j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  id_type(id) {
    var type;
    if (id & ~this.space.id_null) {
      if (id & this.space.id_null) {
        return type = "m";
      } else {
        return type = "e";
      }
    } else {
      if (id & this.space.id_null) {
        return type = "n";
      } else {
        return type = "s";
      }
    }
  }

  constructor(space) {
    var a, b, g, id, k, l, ref, t, v;
    this.cycled_coeff = this.cycled_sequence([2, 3, 4, 5, 6, 7, 8, 9]);
    this.space = space;
    this.n = space.n;
    this.blade_ids = (function() {
      var l, ref, results1;
      results1 = [];
      for (l = 0, ref = this.n; (0 <= ref ? l <= ref : l >= ref); 0 <= ref ? l++ : l--) {
        results1.push({
          s: [],
          e: [],
          n: [],
          m: [],
          an: [],
          a: []
        });
      }
      return results1;
    }).call(this);
    for (id = l = 0, ref = 2 ** this.n; (0 <= ref ? l < ref : l > ref); id = 0 <= ref ? ++l : --l) {
      g = space.id_grade(id);
      t = this.id_type(id);
      this.blade_ids[g][t].push(id);
      this.blade_ids[g].a.push(id);
      if ("n" === t || "m" === t) {
        this.blade_ids[g].an.push(id);
      }
    }
    this.blade_id_next = (function() {
      var len, m, ref1, results1;
      ref1 = this.blade_ids;
      results1 = [];
      for (m = 0, len = ref1.length; m < len; m++) {
        a = ref1[m];
        b = {};
        for (k in a) {
          v = a[k];
          b[k] = this.cycled_sequence(this.randomize(v)); // relative order will be equal if not randomized
        }
        results1.push(b);
      }
      return results1;
    }).call(this);
  }

  cycled_sequence(a) {
    var i;
    i = 0;
    return function() {
      var b;
      b = a[i];
      i += 1;
      i = i < a.length ? i : 0;
      return b;
    };
  }

  blade(grade, type, overlap_id) {
    var id, ids, ids_with_overlap;
    // type
    //   s: scalar
    //   e: euclidean
    //   n: null
    //   m: mixed
    //   an: any null
    //   a: any
    //console.log JSON.stringify @blade_ids
    //console.log JSON.stringify @blade_id_next
    id = null;
    if (overlap_id) {
      ids = this.blade_ids[grade][type];
      ids_with_overlap = ids.filter(function(a) {
        return a & overlap_id;
      });
      id = this.random_element(ids_with_overlap);
    }
    if (id == null) {
      id = this.blade_id_next[grade][type]();
    }
    if (id == null) {
      return null;
    }
    return [this.space.id_indices(id), this.cycled_coeff()];
  }

  derived_blade(blade_a, grade_b, type_b, overlap_type) {
    var blade_b, grade_a, id_a, type_a;
    // overlap_type
    //   0: unspecified overlap
    //   1: partial overlap (if possible)
    //   2: full overlap (if possible)
    id_a = this.space.id_from_indices(blade_a[0]);
    type_a = this.id_type(id_a);
    grade_a = this.space.id_grade(id_a);
    switch (overlap_type) {
      case 0:
        return this.blade(grade_b, type_b);
      case 1:
        return this.blade(grade_b, type_b, id_a);
      case 2:
        if (!(grade_a === grade_b && type_a === type_b)) {
          return null;
        }
        blade_b = Array.from(blade_a);
        blade_b[1] = this.cycled_coeff();
        return blade_b;
    }
  }

  mv(config) {
    var a, first, previous, rest;
    // [[grade, type, overlap_type], ...]
    first = this.blade.apply(this, config[0].slice(0, 2));
    if (first == null) {
      return null;
    }
    rest = config.slice(1);
    previous = first;
    rest = (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = rest.length; l < len; l++) {
        a = rest[l];
        previous = this.derived_blade(previous, a[0], a[1], a[2]);
        if (!previous) {
          break;
        }
        results1.push(previous);
      }
      return results1;
    }).call(this);
    if (rest.length !== (config.length - 1)) {
      return null;
    }
    return [first].concat(rest);
  }

  display_combination_tests_ip() {
    var a, b, combinations, config1, config2, g1, g2, grades1, grades2, l, len, len1, len2, len3, len4, len5, len6, m, mv, n, o, p, q, r, ref, ref1, ref2, s, strings, t1, t2;
    combinations = [];
    ref = [[0, "s"], [1, "e"]];
    for (l = 0, len = ref.length; l < len; l++) {
      [g1, t1] = ref[l];
      ref1 = [[0, "s"], [1, "e"]];
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        [g2, t2] = ref1[m];
        if ("e" === t1 && t2 === t1) {
          continue;
        }
        mv = this.mv([[g1, t1, 0], [g2, t2, 0]]);
        combinations.push([[mv[0]], [mv[1]]]);
      }
    }
    config1 = [[[1], "e"], [[1, 2], "n"], [[2], "m"]];
    config2 = [[[1, 2], "e"], [[1, 2], "n"], [[2, 3], "m"]];
    for (n = 0, len2 = config1.length; n < len2; n++) {
      [grades1, t1] = config1[n];
      for (p = 0, len3 = grades1.length; p < len3; p++) {
        g1 = grades1[p];
        for (q = 0, len4 = config2.length; q < len4; q++) {
          [grades2, t2] = config2[q];
          for (r = 0, len5 = grades2.length; r < len5; r++) {
            g2 = grades2[r];
            ref2 = [0, 2];
            for (s = 0, len6 = ref2.length; s < len6; s++) {
              o = ref2[s];
              mv = this.mv([[g1, t1, 0], [g2, t2, o]]);
              if (!mv) {
                continue;
              }
              combinations.push([[mv[0]], [mv[1]]]);
            }
          }
        }
      }
    }
    mv = this.mv([[3, "m", 0], [1, "e", 1]]);
    combinations.push([[mv[0]], [mv[1]]]);
    combinations.push([this.mv([[1, "a", 0], [1, "a", 0]]), this.mv([[2, "a", 0], [3, "a", 0]])]);
    return strings = (function() {
      var len7, results1, u;
      results1 = [];
      for (u = 0, len7 = combinations.length; u < len7; u++) {
        a = combinations[u];
        a = (function() {
          var len8, results2, w;
          results2 = [];
          for (w = 0, len8 = a.length; w < len8; w++) {
            b = a[w];
            results2.push(this.space.mv_to_string(this.space.mv(b)));
          }
          return results2;
        }).call(this);
        results1.push(console.log(this.to_json(a)));
      }
      return results1;
    }).call(this);
  }

  display_combination_tests() {
    var a, b, g1, g2, l, len, ref, results1, t1, t2;
    ref = [0, 1, 2];
    /*
    we want something like this in any order:
    scalar scalar
    scalar 1-blade
    scalar 2-blade
    1-blade-e 1-blade-e
    1-blade-e 1-blade-n
    1-blade-n 1-blade-n
    1-blade-e 2-blade-e
    1-blade-e 2-blade-n
    1-blade-n 2-blade-n
    1-blade-e 3-blade-n
    2-blade-e 2-blade-e
    2-blade-e 2-blade-n
    2-blade-e 3-blade-e
    3-blade 3-blade
    */
    results1 = [];
    for (l = 0, len = ref.length; l < len; l++) {
      g1 = ref[l];
      results1.push((function() {
        var len1, m, ref1, results2;
        ref1 = ["s", "e", "an"];
        results2 = [];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          t1 = ref1[m];
          results2.push((function() {
            var len2, n, ref2, results3;
            ref2 = [0, 1, 2, 3];
            results3 = [];
            for (n = 0, len2 = ref2.length; n < len2; n++) {
              g2 = ref2[n];
              results3.push((function() {
                var len3, p, ref3, results4;
                ref3 = ["s", "e", "an"];
                results4 = [];
                for (p = 0, len3 = ref3.length; p < len3; p++) {
                  t2 = ref3[p];
                  a = this.mv([[g1, t1, 0], [g2, t2, 1]]);
                  if (!a) {
                    continue;
                  }
                  a = (function() {
                    var len4, q, results5;
                    results5 = [];
                    for (q = 0, len4 = a.length; q < len4; q++) {
                      b = a[q];
                      results5.push(this.space.mv_to_string(this.space.mv([b])));
                    }
                    return results5;
                  }).call(this);
                  results4.push(console.log(this.to_json(a)));
                }
                return results4;
              }).call(this));
            }
            return results3;
          }).call(this));
        }
        return results2;
      }).call(this));
    }
    return results1;
  }

};

custom_test_runner_class = class custom_test_runner_class extends test_runner_class {
  // this converts input/output from and to strings for a compact and easier to manage test specification.
  is_mv(a) {
    return Array.isArray(a) && a.every(function(a) {
      return Array.isArray(a) && 3 === a.length;
    });
  }

  is_mv_config(a) {
    return Array.isArray(a) && a.every(function(a) {
      return Array.isArray(a) && 2 === a.length;
    });
  }

  is_mv_to_string(a) {
    if (this.is_mv_config(a)) {
      return this.space.mv_to_string(this.space.mv(a));
    } else {
      return a;
    }
  }

  constructor(space) {
    super();
    this.space = space;
    this.report_compact_failure_strings = function(inp, exp, out) {
      var a;
      return [
        ((function() {
          var l,
        len,
        results1;
          results1 = [];
          for (l = 0, len = inp.length; l < len; l++) {
            a = inp[l];
            results1.push(this.is_mv_to_string(a));
          }
          return results1;
        }).call(this)).join(" "),
        this.is_mv_to_string(exp),
        out
      ];
    };
  }

};

c3 = new sph_ga([1, 1, 1], {
  conformal: true
});

// new test data is generated when needed.
//gen = new test_data_generator_class c3
//gen.display_combination_tests(); process.exit(0)
test_runner = new custom_test_runner_class(c3);

call_with_mv_string = function(f) {
  return function(...a) {
    var b;
    return c3.mv_to_string(f.apply(c3, (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = a.length; l < len; l++) {
        b = a[l];
        results1.push(c3.mv_from_string(b));
      }
      return results1;
    })()));
  };
};

ip_tests = [["ip", call_with_mv_string(c3.ip)], ["2", "3"], "6", ["4", "5e1"], "0", ["6e2", "7"], "0", ["8e1_2", "9e1"], "0", ["9e5", "2e2_4_5"], "18e2_5", ["e5", "e5"], "0", ["e4", "e4"], "0", ["4e1", "5e1"], "20", ["3e4", "4e1_3_4"], "0", ["8e3", "9e1"], "0", ["2e2", "3e2"], "6", ["4e3", "5e1_2"], "0", ["7e1_3", "8e3_5"], "0", ["4e2", "5e2_3"], "20e3", ["7e2", "8e4"], "0", ["8e2", "9e1_2_4"], "-72e1_4", ["3e5", "4e1"], "0", ["6e5", "7e1_3"], "0", ["9e5", "2e4"], "-18", ["3e5", "4e5"], "0", ["5e4", "6e4_5"], "30e4", ["6e1 + 7e4", "8e4_5 + 9e2_3_5"], "-63e2_3 + 56e4"];

gp_tests = [["gp", call_with_mv_string(c3.gp)], ["2", "3"], "6", ["7", "8e1"], "56e1", ["4", "5e1_2"], "20e1_2", ["5e2", "6"], "30e2", ["2e3", "3e3"], "6", ["9e1", "8e2"], "72e1_2", ["7e1_3", "8e3_5"], "56e1_5", ["9e1_2", "8e1_2"], "-72", ["4e1", "5e5"], "20e1_5", ["7e3", "8e1_3"], "-56e1", ["9e1", "2e1_5"], "18e5", ["4e3", "5e1_2_3"], "20e1_2", ["6e1", "7e1_3_4"], "42e3_4", ["8e4", "9"], "72e4", ["5e4", "6e2"], "-30e2_4", ["7e5", "8e5"], "0", ["2e5", "3e1_3"], "6e1_3_5", ["4e4", "5e2_4"], "0", ["7e4", "8e1_2_3"], "-56e1_2_3_4", ["3e2_3", "4"], "12e2_3", ["9e5", "2e2_4_5"], "-18e2_5", ["8e1_2", "9e1"], "-72e2", ["2e1_3", "3e4"], "6e1_3_4", ["5e1_2", "6e1_3"], "-30e2_3", ["2e1_2", "3e1_2_3"], "-6e3", ["6e2_4", "7"], "42e2_4", ["4e1_3", "5e1_3_5"], "-20e5", ["3e3_5", "4e3"], "-12e5", ["5e4_5", "6e5"], "-30e5", ["7e3_5", "8e1_3_5"], "0", ["2e3_4", "3e4_5"], "-6e3_4", ["8e2_4", "9e2_3"], "72e3_4", ["5e2_5", "6e1_2_3"], "30e1_3_5", ["6e4 + 7e5", "8e2_5 + 9e2_3_5"], "48e2 + -54e2_3"];

ep_tests = [["ep", call_with_mv_string(c3.ep)], ["2", "3"], "0", ["4", "5e1"], "20e1", ["6e2", "7"], "42e2", ["3e4", "4e1_3_4"], "0", ["7e5", "8e5"], "0", ["7e1_3", "8e3_5"], "0", ["8e3", "9e1"], "-72e1_3", ["2e2", "3e2"], "0", ["4e3", "5e1_2"], "20e1_2_3", ["4e2", "5e2_3"], "0", ["7e2", "8e4"], "56e2_4", ["2e1", "3e4_5"], "6e1_4_5", ["6e1_4", "5e3"], "-30e1_3_4", ["8e2", "9e1_2_4"], "0", ["9e1_5", "2e3"], "-18e1_3_5", ["6e1 + 7e4", "8e4_5 + 9e2_3_5"], "54e1_2_3_5 + 48e1_4_5 + 63e2_3_4_5"];

test_runner.execute([
  gp_tests,
  ip_tests,
  ep_tests,
  [
    [
      "id_bit_indices",
      (function(...inp) {
        var i,
      l,
      len,
      results1;
        results1 = [];
        for (l = 0, len = inp.length; l < len; l++) {
          i = inp[l];
          results1.push(c3.id_bit_indices(i));
        }
        return results1;
      })
    ],
    (function() {
      var results1 = [];
      for (var l = 0, ref = 2 ** c3.n; 0 <= ref ? l < ref : l > ref; 0 <= ref ? l++ : l--){ results1.push(l); }
      return results1;
    }).apply(this),
    [[],
    [0],
    [1],
    [0,
    1],
    [2],
    [0,
    2],
    [1,
    2],
    [0,
    1,
    2],
    [3],
    [0,
    3],
    [1,
    3],
    [0,
    1,
    3],
    [2,
    3],
    [0,
    2,
    3],
    [1,
    2,
    3],
    [0,
    1,
    2,
    3],
    [4],
    [0,
    4],
    [1,
    4],
    [0,
    1,
    4],
    [2,
    4],
    [0,
    2,
    4],
    [1,
    2,
    4],
    [0,
    1,
    2,
    4],
    [3,
    4],
    [0,
    3,
    4],
    [1,
    3,
    4],
    [0,
    1,
    3,
    4],
    [2,
    3,
    4],
    [0,
    2,
    3,
    4],
    [1,
    2,
    3,
    4],
    [0,
    1,
    2,
    3,
    4]]
  ],
  [["reverse",
  call_with_mv_string(c3.reverse)],
  "e1",
  "e1",
  "e1_2",
  "-1e1_2",
  "e1_2_3",
  "-1e1_2_3",
  "1 + e1",
  "1 + e1",
  "1 + e1 + e1_2",
  "1 + e1 + -1e1_2",
  "1 + e1 + e2 + e1_2 + e1_3 + e1_2_3",
  "1 + e1 + e2 + -1e1_2 + -1e1_3 + -1e1_2_3"],
  [["involute",
  call_with_mv_string(c3.involute)],
  "e1",
  "-1e1",
  "e1_2",
  "e1_2",
  "e1_2_3",
  "-1e1_2_3"],
  [["conjugate",
  call_with_mv_string(c3.conjugate)],
  "e1",
  "-1e1",
  "e1_2",
  "-1e1_2",
  "e1_2_3",
  "e1_2_3"]
]);
